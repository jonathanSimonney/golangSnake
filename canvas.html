<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>test canvas</title>
    <script>
        Array.prototype.containsArray = function(val) {
            var hash = {};
            for(var i=0; i<this.length; i++) {
                hash[this[i]] = i;
            }
            return hash.hasOwnProperty(val);
        };

        // Warn if overriding existing method
        if(Array.prototype.equals)
            console.warn("Overriding existing Array.prototype.equals. Possible causes: New API defines the method, there's a framework conflict or you've got double inclusions in your code.");
        // attach the .equals method to Array's prototype to call it on any array
        Array.prototype.equals = function (array) {
            // if the other array is a falsy value, return
            if (!array)
                return false;

            // compare lengths - can save a lot of time
            if (this.length != array.length)
                return false;

            for (var i = 0, l=this.length; i < l; i++) {
                // Check if we have nested arrays
                if (this[i] instanceof Array && array[i] instanceof Array) {
                    // recurse into the nested arrays
                    if (!this[i].equals(array[i]))
                        return false;
                }
                else if (this[i] != array[i]) {
                    // Warning - two different object instances will never be equal: {x:20} != {x:20}
                    return false;
                }
            }
            return true;
        };
        // Hide method from for-in loops
        Object.defineProperty(Array.prototype, "equals", {enumerable: false});

        function Snake(FirstName, Coordinates, Color){
            this.FirstName = FirstName;
            this.Coordinates = Coordinates;
            this.Color = Color;
            var myObject = this;

            this.drawSnake = function(canvas){
                if (canvas.color.indexOf(this.Color) !== -1){
                    return 'drawing impossible! Please choose another color';
                }
                for (var i in Coordinates){
                    canvas.fillCell(Coordinates[i], this.Color);
                }
            };

            this.move = function(direction){
                //console.log(direction, myObject);
                var newCoordinates = [];
                switch (direction.key){
                    case 'z' :
                        //console.log(myObject.Coordinates, myObject);
                        newCoordinates = [myObject.Coordinates[0][0], myObject.Coordinates[0][1]-1];
                        break;
                    case 'q':
                        newCoordinates = [myObject.Coordinates[0][0]-1, myObject.Coordinates[0][1]];
                        break;
                    case 's':
                        newCoordinates = [myObject.Coordinates[0][0], myObject.Coordinates[0][1]+1];
                        break;
                    case 'd':
                        newCoordinates = [myObject.Coordinates[0][0]+1, myObject.Coordinates[0][1]];
                        break;
                    default:
                        return 'invalid direction supplied. No move will be made.';
                }

                myObject.Coordinates.unshift(newCoordinates);
                if (canvas.appleList.containsArray(newCoordinates)){
                    canvas.createApple(myObject.Coordinates);
                    console.log(canvas.appleList);
                    canvas.appleList = canvas.appleList.filter(function(item) {
                        return !item.equals(newCoordinates);
                    });
                    console.log(canvas.appleList);
                }else{
                    myObject.Coordinates.pop();
                }
                canvas.drawAnew();
            };

            window.addEventListener('keypress', this.move);
        }

        function Canvas(htmlElement, cellWidth, color){
            this.htmlElement = htmlElement;
            this.canvas = htmlElement.getContext('2d');
            this.cellWidth = cellWidth;
            this.color = color;
            this.width = Math.floor(this.htmlElement.width/cellWidth);
            this.height = Math.floor(this.htmlElement.height/cellWidth);
            this.appleList= [];
            var myObject = this;

            this.drawAnew = function(){
                myObject.canvas.fillStyle = color[0];
                var olderFillStyle = color[0];

                for (var i = 0; i < myObject.width; i++){
                    if (myObject.canvas.fillStyle !== olderFillStyle){
                        toggleFillStyle(myObject);
                    }
                    for (var j = 0; j < myObject.height; j++){
                        toggleFillStyle(myObject);
                        if (j === 0){
                            olderFillStyle = myObject.canvas.fillStyle;
                        }

                        var save = myObject.canvas.fillStyle;
                        if (myObject.appleList.containsArray([i,j])){
                            myObject.canvas.fillStyle = 'green';
                        }


                        myObject.canvas.fillRect(i*myObject.cellWidth,j*myObject.cellWidth,myObject.cellWidth,myObject.cellWidth);
                        myObject.canvas.fillStyle = save;
                    }
                }
                snake1.drawSnake(myObject);
            };

            this.fillCell = function(coordinate, color){
                myObject.canvas.fillStyle = color;
                myObject.canvas.fillRect(coordinate[0]*this.cellWidth,coordinate[1]*this.cellWidth,this.cellWidth,this.cellWidth);
            };

            this.getRandomCoordInCanvas = function(){
                var x = Math.floor(Math.random() * myObject.width);
                var y = Math.floor(Math.random() * myObject.height);

                return [x, y];
            };

            this.createApple = function(forbiddenCoordinate){
                while (true){
                    var possibleCoord = myObject.getRandomCoordInCanvas();
                    forbiddenCoordinate = forbiddenCoordinate.concat(myObject.appleList);
                    if (forbiddenCoordinate.indexOf(possibleCoord) === -1){
                        myObject.appleList.push(possibleCoord);
                        forbiddenCoordinate = forbiddenCoordinate.concat(possibleCoord);
                        return possibleCoord;
                    }
                }
            };

            this.drawAnew();
        }

        function toggleFillStyle(canvasObject){
            canvasObject.canvas.fillStyle = canvasObject.canvas.fillStyle === canvasObject.color[0] ? canvasObject.color[1] : canvasObject.color[0];
        }

        var canvas;
        var snake1 = new Snake('testing', [[2, 3], [2,4]], 'yellow');

        window.onload = function () {
            var htmlElementCanvas = document.getElementsByTagName('canvas')[0];
            if (htmlElementCanvas.getContext) {
                canvas = new Canvas(htmlElementCanvas, 50, ['#ff0000', '#0000ff']);
                snake1.drawSnake(canvas);

                for (var i = 0; i<2; i++){
                    canvas.createApple([[2, 3], [2,4]]);
                }
                canvas.drawAnew();
            }
        }
    </script>
</head>
<body>
    <canvas width="1000" height="1000">
    </canvas>
</body>
</html>